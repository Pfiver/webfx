package naga.core.spi.platform.sql.jdbc;

import com.zaxxer.hikari.HikariDataSource;
import naga.core.spi.sql.SqlArgument;
import naga.core.spi.sql.SqlReadResult;
import naga.core.spi.sql.SqlService;
import naga.core.spi.sql.SqlWriteResult;
import naga.core.spi.sql.impl.ConnectionDetails;
import naga.core.spi.sql.impl.SqlServiceImpl;
import naga.core.util.Arrays;
import naga.core.util.async.Future;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * @author Bruno Salmon
 */
public class JdbcSqlService extends SqlServiceImpl {

    public static JdbcSqlService JDBC_SQL_SERVICE = new JdbcSqlService();

    private JdbcSqlService() {
    }

    @Override
    protected SqlService createConnectedSqlService(ConnectionDetails connectionDetails) {
        return new JdbcConnectedSqlService(connectionDetails);
    }

    static class JdbcConnectedSqlService implements SqlService {

        private final DataSource jdbcDataSource;

        public JdbcConnectedSqlService(ConnectionDetails connectionDetails) {
            HikariDataSource hikariDS = new HikariDataSource();
            hikariDS.setDriverClassName(connectionDetails.getDBMS().getJdbcDriverClass());
            hikariDS.setJdbcUrl(connectionDetails.getUrl());
            hikariDS.setUsername(connectionDetails.getUsername());
            hikariDS.setPassword(connectionDetails.getPassword());
            jdbcDataSource = hikariDS;
        }

        @Override
        public Future<SqlReadResult> read(SqlArgument arg) {
            Future<SqlReadResult> future = Future.future();
            try (
                    Connection connection = getConnection();
                    Statement statement = getStatement(arg, connection);
                    ResultSet resultSet = executeStatement(arg, statement)
            ) {
                ResultSetMetaData metaData = resultSet.getMetaData();
                int columnCount = metaData.getColumnCount();
                String[] columnNames = new String[columnCount];
                for (int i = 0; i < columnCount; i++)
                    columnNames[i] = metaData.getColumnName(i + 1);
                List<Object[]> rows = new ArrayList<>();
                while (resultSet.next()) {
                    Object[] columns = new Object[columnCount];
                    for (int i = 0; i < columnCount; i++)
                        columns[i] = resultSet.getObject(i + 1);
                    rows.add(columns);
                }
                int rowCount = rows.size();
                Object[][] values = new Object[rowCount][columnCount];
                for (int i = 0 ; i < rowCount; i++)
                    for (int j = 0; j < columnCount; j++)
                        values[i][j] = rows.get(i)[j];
                future.complete(new SqlReadResult(columnNames, values));
            } catch (Throwable throwable) {
                future.fail(throwable);
            }

            return future;
        }

        @Override
        public Future<SqlWriteResult> write(SqlArgument argument) {
            throw new UnsupportedOperationException("Not yet implemented");
        }

        private Connection getConnection() throws SQLException {
            return jdbcDataSource.getConnection();
        }

        private Statement getStatement(SqlArgument arg, Connection connection) throws SQLException {
            Object[] parameters = arg.getParameters();
            if (Arrays.isEmpty(parameters))
                return connection.createStatement();
            //SqlPrepared p = e.getSqlPrepared();
            //PreparedStatement ps = connection.prepareStatement(p.getSql(), p.getAutoGeneratedKeyColumnNames());
            PreparedStatement ps = connection.prepareStatement(arg.getSql());
            for (int i = 0; i < parameters.length; i++) {
                Object parameter = parameters[i];
                /*if (parameter instanceof ParameterJoinValue)
                    parameter = ((ParameterJoinValue) parameter).getRowId();
                while (parameter instanceof ID)
                    parameter = ((ID) parameter).getObjId();*/
                if (parameter instanceof Date)
                    ps.setDate(i + 1, (Date) parameter);
                else if (parameter instanceof Timestamp)
                    ps.setTimestamp(i + 1, (Timestamp) parameter);
                else if (parameter instanceof java.util.Date) { // Postgres doesn't accept setObject() with dates but requires explicit setDate()
                    java.util.Date date = (java.util.Date) parameter;
                    if (date.getHours() == 0 && date.getMinutes() == 0 && date.getSeconds() == 0)
                        ps.setDate(i + 1, new Date(date.getTime()));
                    else
                        ps.setTimestamp(i + 1, new Timestamp(date.getTime()));
                } else
                    //try {
                    if (parameter != null)
                        ps.setObject(i + 1, parameter);
                    else
                        ps.setNull(i + 1, Types.INTEGER);  // Postgres needs the type in some case (ex: ? is null). Putting Integer to fit keys but what if it's not the case ...?
                    /*} catch (SQLException e1) {
                        e1.printStackTrace();
                        throw e1;
                    }*/
            }
            return ps;
        }

        private ResultSet executeStatement(SqlArgument arg, Statement statement) throws SQLException {
            if (statement instanceof PreparedStatement)
                return ((PreparedStatement) statement).executeQuery();
            return statement.executeQuery(arg.getSql());
        }
    }
}
